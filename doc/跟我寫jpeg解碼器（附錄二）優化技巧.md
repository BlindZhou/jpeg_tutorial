# 優化技巧

如果用配套程式碼來解碼 1920 * 1080 的圖片，大約會需要幾秒鍾，但是使用一般的開圖軟體（例如 eog, eye of gnome），幾乎是瞬間解開，這代表目前的解碼器還有很多的優化空間。

經過簡單的性能分析之後，大約可以發現效能瓶頸的前兩名是

- 離散餘弦變換
- 霍夫曼解碼

其中離散餘弦變換的計算量是霍夫曼解碼的好幾倍，建議優先優化。

## 離散餘弦變換優化

### 快取 cos


## 範式霍夫曼表優化

配套程式碼裡，儲存霍夫曼表的資料結構爲求實作簡單，直接使用了 rust 標準庫裡的 HashMap 。雖然沒錯查詢的複雜度是 O(1) ，但常數項一定相當大，畢竟要執行過一個 hash 函數。

一個很自然的優化方式是把它寫成二元樹，但是利用範式霍夫曼表的特性，我們能寫出一種更簡單，效能也許也更好的實作。

我們[回顧一下](https://github.com/MROS/jpeg_tutorial/blob/master/doc/%E8%B7%9F%E6%88%91%E5%AF%ABjpeg%E8%A7%A3%E7%A2%BC%E5%99%A8%EF%BC%88%E4%B8%89%EF%BC%89%E8%AE%80%E5%8F%96%E9%87%8F%E5%8C%96%E8%A1%A8%E3%80%81%E9%9C%8D%E5%A4%AB%E6%9B%BC%E8%A1%A8.md#%E9%81%8D%E6%AD%B7%E8%91%89%E5%AD%90%E7%AF%80%E9%BB%9E)範式霍夫曼表中碼字的公式：

- 若高度相等：$leaf[n] = leaf[n - 1] + 1$
- 若高度差 1 ：$leaf[n] = (leaf[n - 1] + 1) * 2$
- 若高度差 k ：$leaf[n] = (leaf[n - 1] + 1) * 2^k$

我們可以得到一個重要的觀察，當**碼字長度（高度）相等時，它們的值是連續的**（這裏的連續是指整數上的連續），因爲沒錯都恰好增加 1。